# 큐의 자료구조
    큐는 먼저 들어간 데이터가 먼저 나오는 FIFO(First-In, First-Out), 즉 선입선출 형식을 가진 자료구조이다. 흔히 계산대의 줄 서기를 비유하는데 번저 줄 선 사람이 먼저 계산하고 나간다.

## 큐의 ADT(추상 자료형)
*ADT 란?:  순수하게 기능이 무엇인지를 나열한 것을 가리켜 '추상 자료형' 혹은 ADT라고 한다
    
    enqueue(data): 큐에 데이터를 추가한다.
    
    dequeue(): 큐에서 저장 순서가 가장 앞선 데이터를 데이터를 제거한다.(삭제된 데이터 반환)

    peek(): 큐에서 저장 순서가 가장 앞선 데이터를 반환한다. (삭제는 하지 않음).

    isEmpry(): 큐가 빈 경우 true, 그렇지 않다면 false를 반환 한다.


## 큐의 활용 예시
- 너비우선탐색

- 캐시(Cache)

- 프로세스

- 프린터 출력 순서

- 커피 주문 대기줄

## 자바스크립트에서의 원형 큐
    자바스크립트가 아닌 다른 언어에서 배열을 통해 다뤘을 때 주의할 점이 있다. 바로, 배열의 크기가 정해져있기 때문에, Rear가 더 이상 오른쪽으로 이동할 수 없는 상황이 올 수 있기 때문이다. 하지만, 자바스크립트에선 배열의 크기가 고정되어 있지 않으므로, 신경쓰지 않아도 된다. 실제론 다른 언어에서 이를 대비해 원형Queue로 구현해 공간낭비를 최소화 하는데, 자바스크립트에선 이 원형Queue의 효능이 살짝 떨어지는 편이다.

# 우선 순위 큐와 힙(Heap) 구조
 우선 순위 큐의 핵심 연산은 두가지이다.

 - enqueue 우선 순위큐에 데이터를 삽입하는 행위

- dequeue 우선 순위 큐에 데이터를 꺼내는 행위

일반적인 큐와 크게 다르지 않지만 연산의 결과에는 차이가 있다. 큐는 연산의 결과로, 먼저 들어간 데이터가 먼저 나오지만, 우선순위 큐의 연산 결과는 들어간 순서와 상관없이 우선순위가 높은 데이터가 먼저 나온다.

## 힙이 실제로 사용되는 때

- 우선 순위 큐를 구현하는데 사용.

- 운영체제에서 우선순위 기반의 일들이 스케쥴링 하기위해서 힙을 사용.(우선 순위가 높은 일을 바로 조회 할 수 있기 때문에)

- 다익스트라 알고리즘 (최단 거리 구하기 알고리즘) 에서 최소 비용을 기반으로 그래프를 탐색 할 때 사용.

# 우선순위 큐의 구현 방법
우선순위 큐의 구현방법에는 크게 세 가지로 구분 할 수 있다.

- 배열을 기반으로 구현하는 방법  // 저장:O(N), 삭제:O(1)

- 연결리스트를 기반으로 구현하는 방법 // 저장:O(N), 삭제:O(1)

- 힙(heap) 구조를 이용하는 방법 //저장:O(logN), 삭제:O(logN)

## 힙(Heap) 이란?
힙은 무엇인가를 쌓아 놓은 더미와 흡사하다 하여 지어진 이름이다. (영단어 heap은 "무엇인가 차곡차곡 쌓아 올린 더미"라는 뜻을 가진다.)
힙은 "이진 트리"이되 "완전 이진 트리" 이다. 그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.

- 루트 노드로 올라 갈수록 저장된 값이 커지는 완전 이진트리를 "최대 힙(max heap)"이라고 한다.

- 루트 노드로 올라 갈수록 저장된 값이 작아지는 완전 이진트리를 "최소 힙(min heap)"이라고 한다.

## 힙(Heap) 구현의 어울리는 자료구조는 ??

일반적으로 배열을 사용하여 구현한다. 그이유는 연결리스트 기반으로 구현을 하게 된다면  새로운 노드를 마지막 위치에 추가하는것이 쉽지 않기 때문이다. 사소한 이유같이 보이지만 절대 쉽지 않다.

## 배열을 기반으로 힙을 구현하는데 필요한 지식들

- 노드에 고유 번호를 부여한다. 그리고 그 번호가 각 노드의 데이터가 저장 될 배열의 인덱스 값이 된다.

- 왼쪽 그리고 오른쪽 자식 노드의 인덱스 값을 얻는 방법, 그리고 부모 노드의 인덱스 값을 얻는 방법.

자식 노드의 인덱스 값을 얻는 방법은 데이터의 삭제를 위해서, 부모 노드의 인덱스 값을 얻는 방법은 데이터를 추가하기 위해서 필요하다.

    - 왼쪽 자식 노드의 인덱스 값 : 부모 노드의 인덱스 값 x 2

    - 오른쪽 자식 노드의 인덱스 값 : 부모 노드의 인덱스 값 x 2 + 1

    - 부모 노드의 인덱스 값 : 자식 노드의 인덱스값 / 2 (정수형 나눗셈)

