# 리스트의 자료구조
    1, 리스트 자료구조는 데이터를 나란히 저장하며, 중복된 데이터의 저장을 막지 않는다.
    2, 리스트는 수학적으로 중복을 혀용하지 않는 "집합"과 다르다.
    3, 리스트라는 자료구조는 구현방법에 따라 다음 같이 크게 두가지로 나뉜다.
    
    - 선형 리스트 (Linear List): 배열을 기반으로 구현된 리스트 (흔히 배열 리스트)
    - 연결 리스트 (Linked List): 노드의 연결로 구현된 리스트

## 배열 리스트(Array List)
    배열은 가장 간단한 메모리 데이터 구조다. 거의 모든 프로그래밍 언어에서 배열은 기본으로 내장된 데이터 타입이다.
    배열은 동일한 데이터 타입을 연속적으로 저장한 것이다.(물론 자바스크립트에서는 다른 타입의 데이터도 한 배열에 넣을 수 있다.)

## 연결 리스트(Linked List)
    연결 리스트는 일련의 원소를 배열처럼 차례대로 저장하지만, 원소들이 메모리상에 연속적으로 위치하지 않는다는 점이 다르다.

    다음과 같은 특징이 있다.

    연속되는 항목들이 포인터로 연결된다.
    마지막 항목은 Null을 가리킨다.
    프로그램이 수행되는 동안 크기가 커지거나 작아질 수 있다.
    (시스템 메모리가 허용하는 한) 필요한 만큼 길어질 수 있다.
    메모리 공안을 낭비하지 않는다.(하지만 포인터를 위한 추가의 메모리를 필요로 한다.)
    배열에 비해 데이터의 추가/삽입 및 삭제가 용이하나 순차적으로 탐색하지 않으면 특정 위치의 요소에 접근할 수 없어 일반적으로 탐색 속도가 떨어진다.

    즉 탐색 또는 정렬을 자주 하면 배열을, 추가/삭제가 많으면 연결 리스트를 사용하는 것이 유리하다. 

### 연결 리스트의 ADT(추상 자료형)
*ADT 란?:  순수하게 기능이 무엇인지를 나열한 것을 가리켜 '추상 자료형' 혹은 ADT라고 한다

    addToTail(데이터): 리스트의 맨 끝에 데이터를 추가한다.
    removeAt(위치): 해당 위치에 있는 데이터를 삭제한다.
    indexOf(데이터): 해당 데이터의 인덱스를 반환한다. 존재하지 않을 경우 결과 값은 -1이다.
    removeHead(데이터): 헤드노드 데이터를 삭제한다.
    insert(위치, 데이터): 해당 위치에 데이터를 삽입한다.
    isEmpty(): 데이터가 하나도 없다면 true를, 그 외엔 false를 반환한다.
    size(): 데이터 개수를 반환한다. 배열의 length 프로퍼티와 비슷하다.
    allElementes(): 데이터의 원소을 전부 반환한다.

## 연결리스트(Linked list)와 배열리스트(Array list)의 차이점

### 배열 리스트의 장단점
    장점
    
    1) 내부 구조가 배열로 이루어져 있기 때문에 인덱스로 바로 접근이 가능하여 검색속도가 빠르다. 즉 참조가 쉽다.(컴퓨터를 구성하는 메모리는 RAM(random access memory) 이므로 주소값(인덱스)만 알고 있다면 바로 접근 할 수가 있다.)
    2) 구현이 쉽다.
    
    단점
    1) 배열 리스트를 할당할 때 대략적인 자료의 양을 예측하여 넉넉하게 할당하기 때문에 메모리 낭비가 심하다.(자바스크립트를 제외한 대부분의 언어는 정적으로 배열의 크기를 할당하게 된다.)
    2) 할당된 용량보다 데이터가 많을 시, 더 큰 배열을 생성하고 데이터를 복사해야 해서 효율성이 떨어진다.
    3) 메모리를 차지하는 공간이 연속적으로 되어있기 때문에, 데이터를 추가,삭제 시 빈공간이 생기지 않도록 밀어주고, 땡겨주는 작업이 필요하다.(배열의 처음이나, 중간의 원소를 빼려면 비싼 연산을 하게 된다.)

### 연결 리스트의 장단점
    장점
    
    1) 링크로써 구현 되어 있기 때문에, 자료를 추가하거나 삭제할 시에 링크만 바꿔주면 되기 때문에 추가,삭제가 용이하다.(원소의 이동이 불필요함.)
    2) 메모리 효율성이 우수하다.
    3) 필요할 때 마다 데이터 추가, 삭제를 할 수 있기 때문에 동적으로 배열의 크기를 할 당할 수 있다.

    단점
    1) 원하는 원소(데이터)를 찾을 때까지 포인터로 노드를 탐색하야 하기 때문에 탐색 연산의 비용이 높다.(random access memory의 장점을 살리지 못함.)
    2) 구현이 어렵다.(코딩 자체 난이도가 높음)
