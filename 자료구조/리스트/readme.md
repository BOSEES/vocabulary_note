# 리스트의 자료구조
    1, 리스트 자료구조는 데이터를 나란히 저장하며, 중복된 데이터의 저장을 막지 않는다.
    2, 리스트는 수학적으로 중복을 혀용하지 않는 "집합"과 다르다.
    3, 리스트라는 자료구조는 구현방법에 따라 다음 같이 크게 두가지로 나뉜다.
    
    - 선형 리스트 (Linear List): 배열을 기반으로 구현된 리스트 (흔히 배열 리스트)
    - 연결 리스트 (Linked List): 노드의 연결로 구현된 리스트

## 배열 리스트(Array List)
    배열은 가장 간단한 메모리 데이터 구조다. 거의 모든 프로그래밍 언어에서 배열은 기본으로 내장된 데이터 타입이다.
    배열은 동일한 데이터 타입을 연속적으로 저장한 것이다.(물론 자바스크립트에서는 다른 타입의 데이터도 한 배열에 넣을 수 있다.)

## 연결 리스트(Linked List)
    연결 리스트는 일련의 원소를 배열처럼 차례대로 저장하지만, 원소들이 메모리상에 연속적으로 위치하지 않는다는 점이 다르다.

    다음과 같은 특징이 있다.

    연속되는 항목들이 포인터로 연결된다.
    마지막 항목은 Null을 가리킨다.
    프로그램이 수행되는 동안 크기가 커지거나 작아질 수 있다.
    (시스템 메모리가 허용하는 한) 필요한 만큼 길어질 수 있다.
    메모리 공안을 낭비하지 않는다.(하지만 포인터를 위한 추가의 메모리를 필요로 한다.)
    배열에 비해 데이터의 추가/삽입 및 삭제가 용이하나 순차적으로 탐색하지 않으면 특정 위치의 요소에 접근할 수 없어 일반적으로 탐색 속도가 떨어진다.

    즉 탐색 또는 정렬을 자주 하면 배열을, 추가/삭제가 많으면 연결 리스트를 사용하는 것이 유리하다. 

### 연결 리스트의 ADT(추상 자료형)
*ADT 란?:  순수하게 기능이 무엇인지를 나열한 것을 가리켜 '추상 자료형' 혹은 ADT라고 한다

    addTohead(데이터): 리스트의 처음에 데이터를 추가한다.

    addToTail(데이터): 리스트의 맨 끝에 데이터를 추가한다.

    removeAt(위치): 해당 위치에 있는 데이터를 삭제한다.

    indexOf(데이터): 해당 데이터의 인덱스를 반환한다. 존재하지 않을 경우 결과 값은 -1이다.

    removeHead(데이터): 헤드노드 데이터를 삭제한다.

    insert(위치, 데이터): 해당 위치에 데이터를 삽입한다.

    isEmpty(): 데이터가 하나도 없다면 true를, 그 외엔 false를 반환한다.

    size(): 데이터 개수를 반환한다. 배열의 length 프로퍼티와 비슷하다.
    
    allElementes(): 데이터의 원소을 전부 반환한다.

## 연결리스트(Linked list)와 배열리스트(Array list)의 차이점

### 배열 리스트의 장단점
    장점
    
    1) 내부 구조가 배열로 이루어져 있기 때문에 인덱스로 바로 접근이 가능하여 검색속도가 빠르다. 즉 참조가 쉽다.(컴퓨터를 구성하는 메모리는 RAM(random access memory) 이므로 주소값(인덱스)만 알고 있다면 바로 접근 할 수가 있다.)
    2) 구현이 쉽다.
    
    단점
    1) 배열 리스트를 할당할 때 대략적인 자료의 양을 예측하여 넉넉하게 할당하기 때문에 메모리 낭비가 심하다.(자바스크립트를 제외한 대부분의 언어는 정적으로 배열의 크기를 할당하게 된다.)
    2) 할당된 용량보다 데이터가 많을 시, 더 큰 배열을 생성하고 데이터를 복사해야 해서 효율성이 떨어진다.
    3) 메모리를 차지하는 공간이 연속적으로 되어있기 때문에, 데이터를 추가,삭제 시 빈공간이 생기지 않도록 밀어주고, 땡겨주는 작업이 필요하다.(배열의 처음이나, 중간의 원소를 빼려면 비싼 연산을 하게 된다.)

### 연결 리스트의 장단점
    장점
    
    1) 링크로써 구현 되어 있기 때문에, 자료를 추가하거나 삭제할 시에 링크만 바꿔주면 되기 때문에 추가,삭제가 용이하다.(원소의 이동이 불필요함.)
    2) 메모리 효율성이 우수하다.
    3) 필요할 때 마다 데이터 추가, 삭제를 할 수 있기 때문에 동적으로 배열의 크기를 할 당할 수 있다.

    단점
    1) 원하는 원소(데이터)를 찾을 때까지 포인터로 노드를 탐색하야 하기 때문에 탐색 연산의 비용이 높다.(random access memory의 장점을 살리지 못함.)
    2) 구현이 어렵다.(코딩 자체 난이도가 높음)

# 단방향 연결리스트를 구현하면서 느낀점.
- 간단한 코드를 구성해 구현했지만 데이터의 구조가 조금만 복잡해진다면 난이도가 엄청 올라 갈거 같다.
- 항상 head 노드의 기준으로 시작한다.
- 시간복잡도 O(n)의 성능을 가지고 있다.
- 노드를 추가하는 방법중에는 head의 추가하는 방법과 tail에 추가하는 방법이 있는데 head가 더 좋은거같다. 왜냐하면 
1) tail이라는 변수가 필요가 없어진다(메모리 절약)
2) 저장된 순서가 인덱스순서처럼 유지를 할 수 없지만
연결리스트라는 자료구조 자체가 자료의 순서를 필요로하는 구조가 아니기 때문.

# 양방향 연결리스트를 구현하면서 느낀점.
- prev라는 변수 하나를 노드에 더 할당해 이전 노드의 주소를 기록. 좀더 코드가 길어진 것 말고는 크게 어려움이 없음.
- Date() 객체를 통해 성능 테스트 결과 리스트의 길이의 절반을 기준으로 앞뒤로 탐색을 하게끔 만들었음. 상당히 괜찮다. 시간이 비약적으로 줄어들었다.
- head 포인터를 따라가는것보단 더미 노드를 만들어 코드의 간략함을 추구하는것도 나쁘진 않을꺼같다.
- 중간에 오타 오류가 하나 있었는데 오류 찾아내기가 상당히 어려움. 난이도 상승.

# 배열 리스트(스택)를 구현하면서 느낀점.
- 구현난이도는 배열을 구현할때 처럼 굉장히 쉬움.마치 단방향 연결리스트와 기능이 굉장히 적은 ADT의 콜라보.
- 함수가 아닌 class를 이용해 객채를 생성하였는데 이 클래스를 컨트롤하기 위해선 this를 사용해야한다.하지만 this를 사용하는데 애로우 펑션을 사용해서 에러가 났음. 구조적으로 standard function과 arrowfunction은 돌아가는 구조자체가 다른듯하다.
- ArrayList의 head pointer 를 따라가도록 구조를 만들었지만... 기본 배열의 버릇처럼  while 문을 통해 꼬리노드를 따라가고 있었다. 결과적으로 삭제하는 과정에서 이전 노드의 데이터를 담을 방법이 좀처럼 떠오르지않아 깨달음. 기껏 tail이 아닌 head를 활용하는 과정에서 스택의 고정 관념 때문에 생긴 바보짓이었다.

# 큐 연결리스트를 구햔하면서 느낀점.
- 큐라는 구조는 일반적인 배열을 이용했을땐 생각보다 단순한 구조는 아니었지만. 링크를 활용한 연결리스트에서는 구현 난이도가 상당히 쉬웠다.