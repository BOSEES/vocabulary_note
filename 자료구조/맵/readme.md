## 해시 테이블(Hash Table)이란?
해시 테이블은 어떤 특정 값을 받으면 그 값을 해시 함수에 통과시켜 나온 인덱스(index)에 저장하는 자료구조이다.
또 테이블은 "사전 구조"라고도 불린다. 더불어 맵(map)이라고 불리기도 한다.

---

### 직접 주소 테이블(Direct Address Table)
해시 테이블의 아이디어는 직접 주소 테이블 이라는 자료구조에서 부터 출발 한다. 직접 주소 테이블은 입력받은 value가 곧 key가 되는 데이터 매핑 방식이다. 코드로 보면 더 이해가 쉽다.

    class DirectAddressTable {
      constructor () {
        this.table = [];
      }

      setValue (value = -1) {
        this.table[value] = value;
      }

      getValue (value = -1) {
        return this.table[value];
      }

      getTable () {
        return this.table;
      }
    }

    const myTable = new DirectAddressTable();
    myTable.setValue(3);
    myTable.setValue(10);
    myTable.setValue(90);

    console.log(myTable.getTable());

    
--
    
    [ <3 empty items>, 3, <6 empty items>, 10, <79 empty items>, 90 ]
우리가 3을 테이블에 넣으면 이 값은 배열의 3번 인덱스의 요소가 되고 90을 넣으면 90번 인덱스의 요소가 된다. 그야말로 초 심플하다. 이렇게 직접 주소 테이블을 사용할때는 들어오는 값이 뭔지 알면 이 값이 저장된 인덱스도 함께 알 수 있기 때문에 저장된 데이터에 바로 접근해서 값을 가져올 수 있다.

    myTable.getValue(3); // 3

찾고자 하는 값과 테이블의 인덱스가 동일하므로 테이블을 뒤적거릴 필요없이 값이 저장된 공간에 바로 접근해서 값을 가져올 수 있으므로 시간복잡도는 O(1)O(1)이다. 마찬가지로 테이블에 있는 값을 삽입, 수정, 삭제하는 행위도 값이 어디 있는지만 알고있으면 모두 한방에 해결할 수 있으므로 역시 O(1)O(1)의 시간복잡도로 해결할 수 있다.

보통 이런 단순한 자료구조에서 값을 탐색, 삽입, 수정, 삭제하는 알고리즘이 시간을 잡아먹게 되는 이유는 대부분 비슷비슷하다.

- 내가 찾고 싶은 값이 어디 있는지 모른다. 일단 효율적으로 뒤져보자(이진트리탐색 같은 경우)

- 내가 이 값을 삽입하거나 삭제하면 다른 값이 영향을 받는다(링크드 리스트 같은 경우)

이렇게 직접 주소 테이블은 내가 보고 싶은 값이 어디 있는지 알고 있기 때문에 바로 접근해서 이후 작업을 수행할 수 있다는 점에서 굉장히 편리하다고 할 수 있다.

하지만 직접 주소 테이블도 당연히 단점이 있다. 바로 공간의 효율성이 좋지 않다는 것이다. 방금 선언했던 myTable의 테이블 상태를 한번 보면 이해가 바로 된다. 이 테이블에는 3, 10, 90의 값을 넣었고 이 값들은 크기 차이가 꽤나 큰 편이다.

그 결과 우리의 myTable은 이렇게 듬성듬성한 구조로 데이터를 저장하게 된 것이다.

    Array(91) [
    0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90]

위에서도 볼 수 있듯이 저장된 데이터를 제외하고 0으로 채워진 나머지 공간은 값은 없지만 메모리 공간은 할당되어 있는 상태인 것이다. 즉, 사용하지 않는 아까운 공간이다. 즉 테이블에 넣고자 하는 데이터의 값의 범위보다 값의 개수가 작다면 공간적인 효율이 떨어지는 것이다.

이런 상황을 적재율이 낮다라고 표현하는데, 적재율은 값의 개수/테이블의 크기로 나타내게 된다. 필자가 방금 만든 이 테이블의 현재 적재율은 3/91 = 0.03296...으로 약 3% 정도이므로 높은 적재율은 아니라고 볼 수 있다.

만약 1000과 같이 큰 값이 하나만 더 테이블에 들어온다고 해도 테이블의 크기는 1001이 되고 적재율은 0.003996...으로 약 0.4%가 된다. 즉, 직접 주소 테이블이 큰 힘을 발휘할 수 있는 순간은 1, 2, 3과 같이 연속적인 값을 저장하거나 혹은 값들의 범위 차이가 크지 않은 데이터라고 할 수 있다.

---

## 해쉬 함수로 보완

이렇게 직접 주소 테이블은 값에 접근하기는 편하지만 공간 효율이 좋지 않다는 단점이 있다. 그래서 이 단점을 보완한 게 바로 해시 테이블인 것이다.

해시 테이블은 직접 주소 테이블처럼 값을 바로 테이블의 인덱스로 사용하는 것이 아니라 해시 함수(Hash Function)이라는 것에 한번 통과시켜서 사용한다. 해시 함수는 임의의 길이를 가지는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 이때 이 함수가 뱉어내는 결과물을 해시(Hash)라고 부른다.

### 간단한 해쉬 함수의 예제

    const myTableSize = 5;
    const myHashTable = new Array(myTableSize);

    function hashFunction (key) {
      // 들어온 값을 테이블의 크기로 나눠주고 나머지를 반환하면 된다.
      return key % myTableSize;
    }

    myHashTable[hashFunction(1991)] = 1991;
    myHashTable[hashFunction(1234)] = 1234;
    myHashTable[hashFunction(5678)] = 5678;

    console.log(myHashTable); // [empty, 1991, empty, 5678, 1234]
들어온 값들은 1991, 1234, 5678로, 해시 테이블의 사이즈인 5보다 훨씬 큰 값이지만 해시 함수를 거친 결과 0~4 사이의 값만 반환되기 때문에 필자의 작고 귀여운 해시 테이블 안에 값이 차곡차곡 저장될 수 있다.

---

## 해쉬 충돌 (Collision)

해시 테이블의 단점도 있다. 그 단점은 바로 해시의 충돌이다. 충돌이 뭔지 설명하기 전에 필자의 해시 함수를 가지고와서 한번 충돌을 일으켜보고 직접 확인해보자.

    hashFunction(1991) // 1
    hashFunction(6) // 1

다른 값을 해시 함수에 넣었지만 같은 값이 튀어나오는 것이 바로 충돌(Collision)이다.

### 좋은 해쉬를 디자인하기 위해선 어떠한 방법?

결국 좋은 해쉬함수를 만들어야한다. 테이블의 메모리를 할당하는데에 있어서 분포가 골고루 되어있는 상태가 좋은 해쉬함수를 쓰고있다는 반증이기도 하다. 
좋은 해쉬 함수를 만들기 위해선 키값을 해쉬할때 일부분을 참조하지 않고 전체를 참조하여 해쉬 값을 만드는데 경우의 수를 훨씬 다양하게 만들수 있어서 좋다.
그중 2개의 방법은

- 자릿수 선택(Digit Selection) 방법 : 자릿수를 기준으로 해쉬를 하는 방법.
- 자릿수 폴딩(Digit Folding) 방법 : 자릿수를 더해 해쉬를 하는 방법 (마치 종이를 접어 겹친다는 표현에서 유래 됨)

결국 해쉬테이블은 구현하는데 있어서 중요한점은 시간복잡도보단 "키의 특성과 저장공간의 크기를 고려하는 설계"가 우선이 되어야 한다.

# 해쉬 충돌(Collision)을 막기 위한 방법은?
- 분리 연결법 (Closed addressing method)
    - 체이닝(Chaining)

- 개방 주소법 (Open addressing method)

    - 선형 탐사법(Liner Probing) : 충돌이 났을 때 순차적으로 정해진 만큼의 옆 공간(index)에 저장하는 방식

    - 제곱 탐사법(Quadratic Probing) : 충돌이 났을때 탐사하는 폭이 고정폭이 아닌 제곱으로 탐사해 저장하는 방식 

## 분리 연결법(Separate Chaining)
- 분리 연결법은 개방 주소법과는 다른 개념으로 접근하는 충돌 우회 방법이다. 분리 연결법은 해쉬 테이블의 버킷에 하나의 값이 아니라 링크드 리스트(Linked List)나 트리(Tree)를 사용한다
## 선형 탐사법의 단점
- 같은 해시가 여러 번 나오는 경우 선형 탐사법을 사용하면 데이터가 연속되게 저장될 가능성이 높아진다. 즉, 데이터의 밀집도가 높아진다는 것이다. 이런 경우 해시의 값이 1이 나왔을 때 뿐만 아니라 2나 3이 나왔을 때도 충돌이 발생한다.

이게 진짜 악순환의 반복인데, 이런 식으로 충돌이 계속 될 수록 데이터가 연속되게 저장되기 때문에 나중에 가면 데이터가 밀집되어 있는 거대한 덩어리가 생긴다. 그럼 해시로 어떤 값이 나오더라도 그 덩어리가 차지한 인덱스와 충돌이 날 확률이 올라가고, 충돌난 값은 또 그 덩어리 뒤에 저장되게 되므로 데이터 덩어리가 더 커진다

## 제곱 탐사법은?
- 제곱 탐사법을 사용하면 충돌이 발생하더라도 데이터의 밀집도가 선형 탐사법보다 많이 낮기 때문에 다른 해시값까지 영향을 받아서 연쇄적으로 충돌이 발생할 확률이 많이 줄어든다.

그러나 해쉬 값이 같으면,충돌 발생시 빈 슬롟을 찾기위해서 접근하는 위치가 동일하다는건 피할수 없다.
결국 데이터의 군집은 피할 수 없는 숙명이므로 이 현상을 이차 군집화(Secondary Clustering) 혹은 클러스터 라고 부른다.

## 더 개선 할수는 없을까?

- 이중 해싱(Double Hashing) : 말 그대로 해시 함수를 이중으로 사용하는 방식.

하나는 기존과 마찬가지로 최초 해시를 얻을 때 사용하고, 다른 하나는 충돌이 났을 경우 탐사 이동폭을 얻기 위해 사용한다. 이렇게 하면 최초 해시로 같은 값이 나오더라도 다시 다른 해시 함수를 거치면서 다른 탐사 이동폭이 나올 확률이 높기 때문에 매번 다른 공간에 값이 골고루 저장될 확률도 높아진다.
이때 소수를 통해 2차 해싱을 진행하면 통계적으로 클러스터를 줄일수 있다고 한다.

# 테이블 크기 재할당 (Resizing)
해시 테이블은 고정적인 공간을 할당해서 많은 데이터를 담기 위한 자료구조인 만큼 언젠가 데이터가 넘치기 마련이다.

개방 주소법을 사용하는 경우에는 위에서 예시로 작성했던 코드에서 풀방입니다가 출력되는 상황, 즉 테이블이 실제로 꽉 차서 더이상 저장을 못하는 상황이 발생할 것이고, 분리 연결법을 사용하는 경우에는 테이블에 빈 공간이 적어지면서 충돌이 발생할 수록 각각의 버킷에 저장된 리스트가 점점 더 길어져서 리스트를 탐색하는 리소스가 너무 늘어난 상황이 발생할 것이다.

그렇기 때문에 해시 테이블은 꽉꽉 아낌없이 채우기보다는 어느 정도 비워져 있는 것이 성능 상 더 좋으며, 해시 테이블을 운용할 때는 어느 정도 데이터가 차면 테이블의 크기를 늘려줘야한다.

이건 특별한 알고리즘이라기보다는 그냥 기존 크기의 두 배정도로 새로운 테이블을 선언해서 기존 테이블의 데이터를 그대로 옮겨 담는 방법을 사용한다. 분리 연결법을 사용한 해시 테이블의 경우 재해싱(Rehashing)을 통해 너무 길어진 리스트의 길이를 나누어서 다시 저장하는 방법을 사용하기도 한다.

