## 해시 테이블(Hash Table)이란?
해시 테이블은 어떤 특정 값을 받으면 그 값을 해시 함수에 통과시켜 나온 인덱스(index)에 저장하는 자료구조이다.

---

### 직접 주소 테이블(Direct Address Table)
해시 테이블의 아이디어는 직접 주소 테이블 이라는 자료구조에서 부터 출발 한다. 직접 주소 테이블은 입력받은 value가 곧 key가 되는 데이터 매핑 방식이다. 코드로 보면 더 이해가 쉽다.

    class DirectAddressTable {
      constructor () {
        this.table = [];
      }

      setValue (value = -1) {
        this.table[value] = value;
      }

      getValue (value = -1) {
        return this.table[value];
      }

      getTable () {
        return this.table;
      }
    }

    const myTable = new DirectAddressTable();
    myTable.setValue(3);
    myTable.setValue(10);
    myTable.setValue(90);

    console.log(myTable.getTable());

    
--
    
    [ <3 empty items>, 3, <6 empty items>, 10, <79 empty items>, 90 ]
우리가 3을 테이블에 넣으면 이 값은 배열의 3번 인덱스의 요소가 되고 90을 넣으면 90번 인덱스의 요소가 된다. 그야말로 초 심플하다. 이렇게 직접 주소 테이블을 사용할때는 들어오는 값이 뭔지 알면 이 값이 저장된 인덱스도 함께 알 수 있기 때문에 저장된 데이터에 바로 접근해서 값을 가져올 수 있다.

    myTable.getValue(3); // 3

찾고자 하는 값과 테이블의 인덱스가 동일하므로 테이블을 뒤적거릴 필요없이 값이 저장된 공간에 바로 접근해서 값을 가져올 수 있으므로 시간복잡도는 O(1)O(1)이다. 마찬가지로 테이블에 있는 값을 삽입, 수정, 삭제하는 행위도 값이 어디 있는지만 알고있으면 모두 한방에 해결할 수 있으므로 역시 O(1)O(1)의 시간복잡도로 해결할 수 있다.

보통 이런 단순한 자료구조에서 값을 탐색, 삽입, 수정, 삭제하는 알고리즘이 시간을 잡아먹게 되는 이유는 대부분 비슷비슷하다.

- 내가 찾고 싶은 값이 어디 있는지 모른다. 일단 효율적으로 뒤져보자(이진트리탐색 같은 경우)

- 내가 이 값을 삽입하거나 삭제하면 다른 값이 영향을 받는다(링크드 리스트 같은 경우)

이렇게 직접 주소 테이블은 내가 보고 싶은 값이 어디 있는지 알고 있기 때문에 바로 접근해서 이후 작업을 수행할 수 있다는 점에서 굉장히 편리하다고 할 수 있다.

하지만 직접 주소 테이블도 당연히 단점이 있다. 바로 공간의 효율성이 좋지 않다는 것이다. 방금 선언했던 myTable의 테이블 상태를 한번 보면 이해가 바로 된다. 이 테이블에는 3, 10, 90의 값을 넣었고 이 값들은 크기 차이가 꽤나 큰 편이다.

그 결과 우리의 myTable은 이렇게 듬성듬성한 구조로 데이터를 저장하게 된 것이다.

    Array(91) [
    0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90]

위에서도 볼 수 있듯이 저장된 데이터를 제외하고 0으로 채워진 나머지 공간은 값은 없지만 메모리 공간은 할당되어 있는 상태인 것이다. 즉, 사용하지 않는 아까운 공간이다. 즉 테이블에 넣고자 하는 데이터의 값의 범위보다 값의 개수가 작다면 공간적인 효율이 떨어지는 것이다.

이런 상황을 적재율이 낮다라고 표현하는데, 적재율은 값의 개수/테이블의 크기로 나타내게 된다. 필자가 방금 만든 이 테이블의 현재 적재율은 3/91 = 0.03296...으로 약 3% 정도이므로 높은 적재율은 아니라고 볼 수 있다.

만약 1000과 같이 큰 값이 하나만 더 테이블에 들어온다고 해도 테이블의 크기는 1001이 되고 적재율은 0.003996...으로 약 0.4%가 된다. 즉, 직접 주소 테이블이 큰 힘을 발휘할 수 있는 순간은 1, 2, 3과 같이 연속적인 값을 저장하거나 혹은 값들의 범위 차이가 크지 않은 데이터라고 할 수 있다.

---

## 해쉬 함수로 보완

이렇게 직접 주소 테이블은 값에 접근하기는 편하지만 공간 효율이 좋지 않다는 단점이 있다. 그래서 이 단점을 보완한 게 바로 해시 테이블인 것이다.

해시 테이블은 직접 주소 테이블처럼 값을 바로 테이블의 인덱스로 사용하는 것이 아니라 해시 함수(Hash Function)이라는 것에 한번 통과시켜서 사용한다. 해시 함수는 임의의 길이를 가지는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 이때 이 함수가 뱉어내는 결과물을 해시(Hash)라고 부른다.

### 간단한 해쉬 함수의 예제

    const myTableSize = 5;
    const myHashTable = new Array(myTableSize);

    function hashFunction (key) {
      // 들어온 값을 테이블의 크기로 나눠주고 나머지를 반환하면 된다.
      return key % myTableSize;
    }

    myHashTable[hashFunction(1991)] = 1991;
    myHashTable[hashFunction(1234)] = 1234;
    myHashTable[hashFunction(5678)] = 5678;

    console.log(myHashTable); // [empty, 1991, empty, 5678, 1234]
들어온 값들은 1991, 1234, 5678로, 해시 테이블의 사이즈인 5보다 훨씬 큰 값이지만 해시 함수를 거친 결과 0~4 사이의 값만 반환되기 때문에 필자의 작고 귀여운 해시 테이블 안에 값이 차곡차곡 저장될 수 있다.

---

## 해쉬 충돌 (Collision)

해시 테이블의 단점도 있다. 그 단점은 바로 해시의 충돌이다. 충돌이 뭔지 설명하기 전에 필자의 해시 함수를 가지고와서 한번 충돌을 일으켜보고 직접 확인해보자.

    hashFunction(1991) // 1
    hashFunction(6) // 1

다른 값을 해시 함수에 넣었지만 같은 값이 튀어나오는 것이 바로 충돌(Collision)이다.

